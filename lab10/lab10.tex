\documentclass[11.4pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage[a4paper,margin=1.0in,footskip=0.25in]{geometry}

\makeatletter
\newcommand{\verbatimfont}[1]{\renewcommand{\verbatim@font}{\ttfamily#1}}
\graphicspath{ {/home/danilyanich/Projects/C++/Схема единственного деления/} }
\author{Ткачук Павел}
\title{Схема единственного деления}
\begin{document}
	\begin{titlepage}
		
		\centering
		{\scshape\LARGE ФПМИ БГУ \par}
		\vfill
		\begin{flushleft}
		{\scshape\Large Вычислительные методы алгебры\par Лаборатоная работа 10\par}
		\vspace{1cm}
		{\huge\bfseries Нахождение собственных значений и собственных векторов степенным методом\par}
		\end{flushleft}
		\vspace{10cm}
		\begin{flushright}
		\large
		Подготовил:\par
		Ткачук Павел\par
		2 курс 1 группа\par
		\vspace{0.5cm}
		Преподаватель:\par
		Будник Анатолий Михайлович
		\end{flushright}
		
		\vfill
		{\large \today}
	\end{titlepage}
\section{Постановка задачи}
	Входные данные:
	\[ A_{\text{исх.}}=
		\left[
			\begin{array}{ccccc}
				0.6444 & 0.0000 & -0.1683 & 0.1184 & 0.1973\\
				-0.0395 & 0.4208 & 0.0000 & -0.0802 & 0.0263\\
				0.0132  & -0.1184 & 0.7627 & 0.0145 & 0.0460\\
				0.0395 & 0.0000 & -0.0960 & 0.7627 & 0.0000\\
				0.0263 & -0.0395 & 0.1907 & -0.0158 & 0.5523
			\end{array}
		\right]
	\]
	Для того чтобы все собственные значения были действительными числами, домножим слева исходную матрицу на ей транспонированную:
	\[ A=A_{\text{исх.}}A_{\text{исх.}}^T=
		\left[
			\begin{array}{ccccc}
				 0.4965221 & -0.02976049 & -0.10906373 &  0.13191428 & 0.09195098\\
 				-0.02976049 & 0.18575662 & -0.05029722 & -0.06272879 & -0.0018678\\
 				-0.10906373 & -0.05029722 & 0.59823034 & -0.06163865 &  0.17564755\\
 				 0.13191428 & -0.06272879 & -0.06163865 &  0.59248754 & -0.02931901\\
 				 0.09195098 & -0.0018678  & 0.17564755 & -0.02931901 &  0.34390336
			\end{array}
		\right]
	\]
	Задача:
	\begin{enumerate}
		\item Для данной матрицы $A$ вычислить максимальное по модулю собственное значение $\lambda_{max}$, собственный вектор $\vec{v}$ соответствующий максимальному значению, а также количество итераций за которое было получено решение. $\varepsilon=10^{-5}$
		\item Найти невязку $\vec{r} = A\vec{v} - \lambda_{max}\vec{v} $
	\end{enumerate}
\section{Алгоритм}
	\begin{enumerate}
		\item Полагаем $k=0$, $y^{(0)}=(1, 1, \ldots, 1)$, $\lambda^{(0)} = 1$ и $\varepsilon = 10^{-5}$
		\item Вычисляем следующее приближение 
		\begin{equation*}
			\begin{aligned}
				&y^{(k+1)} =Ay^{(k)},\\
				&\lambda^{(k+1)} = \dfrac{1}{n}\sum\limits_{i=1}^{n}\dfrac{y^{(k+1)}_i}{y^{(k)}_i}
			\end{aligned}
		\end{equation*}
		\item Если выполнено условие $\|\lambda^{(k+1)}-\lambda^{(k)}\|<\epsilon$, завершаем процесс  и в качестве приближенного собственного значения берем $\lambda^{\ast} \cong \lambda^{(k+1)}$, а в качестве собственного вектора $\vec{v} \cong y^{(k+1)}$. Иначе нормируем $y^{(k+1)}$ полагаем $k=k+1$, и переходим к пункту 2 алгоритма.
	\end{enumerate}
\section{Результаты и вывод}
	\subsection{Входные данные}
		0.6444 0.0000 -0.1683 0.1184 0.1973\\
		-0.0395 0.4208 0.0000 -0.0802 0.0263\\
		0.0132 -0.1184 0.7627 0.0145 0.0460\\
		0.0395 0.0000 -0.0960 0.7627 0.0000\\
		0.0263 -0.0395 0.1907 -0.0158 0.5523\\
	\subsection{Выходные данные}
\begin{verbatim}
Ищем собственные вектор матрицы
Исходная матрица:
[[ 0.4965221  -0.02976049 -0.10906373  0.13191428  0.09195098]
 [-0.02976049  0.18575662 -0.05029722 -0.06272879 -0.0018678 ]
 [-0.10906373 -0.05029722  0.59823034 -0.06163865  0.17564755]
 [ 0.13191428 -0.06272879 -0.06163865  0.59248754 -0.02931901]
 [ 0.09195098 -0.0018678   0.17564755 -0.02931901  0.34390336]]
Собственное значение:  0.780801286504
Собственный вектор:  [ 0.45192578 -0.02699165 -0.6529953   0.57128303 -0.20559032]
Количество итераций:  49
Невязка:  [  4.45401707e-06   3.66055326e-06  -3.76876208e-05   5.62171434e-06
  -1.90591697e-05]
Норма невязки:  4.29936076537e-05
 \end{verbatim}
	\subsection{Вывод}
	Данный метод относится к степенным. С его помощью можно получить максимальное собственное значение с любой точностью, однако количество шагов, требуемое для получения достаточно точного результата (в данном случае с точностью $\varepsilon=10^{-5}$), значительно меньше, чем в точных методах. Можно сделать вывод, что во многих задачах, где требуется получить собственные значения с определенным свойством, выгоднее использовать степенные методы  так как можно получить решение с такой же погрешностью как и в точных методах (в точных методах появляется погрешность вычислений), однако за меньшее количество операций. \par
\newpage
\section{Листинг кода}
\begin{verbatim}
import numpy as np
import numpy.linalg as linalg

def eigvals(matr_A, eps):
    A = matr_A.copy()
    n = len(A)
    y = np.array([1 for i in range(n)])
    converge = False
    count = 0
    prev = 1
    while not converge:
        count +=1
        y_new = np.dot(A, y)
        next = sum(y_new[i] / y[i] for i in range(n)) / n
        converge = abs(next - prev) <= eps
        prev = next
        y = y_new / linalg.norm(y_new)
    return y, prev, count

file = open("matrix", "r")  # Чтение файла
A, b = [], []
for line in file:
    A.append([float(el) for el in line.split()[:-1]])
    b.append(float(line.split().pop()))
A = np.array(A)
A = np.dot(A, A.transpose())
b = np.array(b)
print("Ищем собственные вектор матрицы")
print("Исходная матрица:")
print(A)
ans = eigvals(A, 0.00001)
print("Собственное значение: ", ans[1])
print("Собственный вектор: ", ans[0])
print("Количество итераций: ", ans[2])
print("Невязка: ", np.dot(A, ans[0]) - ans[0] * ans[1])
print("Норма невязки: ", linalg.norm(np.dot(A, ans[0]) - ans[0] * ans[1]))
\end{verbatim}
\end{document}