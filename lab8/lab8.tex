\documentclass[11.4pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage[a4paper,margin=1.0in,footskip=0.25in]{geometry}

\makeatletter
\newcommand{\verbatimfont}[1]{\renewcommand{\verbatim@font}{\ttfamily#1}}
\graphicspath{ {/home/danilyanich/Projects/C++/Схема единственного деления/} }
\author{Ткачук Павел}
\title{Схема единственного деления}
\begin{document}
	\begin{titlepage}
		
		\centering
		{\scshape\LARGE ФПМИ БГУ \par}
		\vfill
		\begin{flushleft}
		{\scshape\Large Вычислительные методы алгебры\par Лаборатоная работа 8 \par}
		\vspace{1cm}
		{\huge\bfseries Нахождение собственных значений и собственных векторов методом Данилевского\par}
		\end{flushleft}
		\vspace{10cm}
		\begin{flushright}
		\large
		Подготовил:\par
		Ткачук Павел\par
		2 курс 1 группа\par
		\vspace{0.5cm}
		Преподаватель:\par
		Будник Анатолий Михайлович
		\end{flushright}
		
		\vfill
		{\large \today}
	\end{titlepage}
\section{Постановка задачи}
	Входные данные:
	\[ A_{\text{исх.}}=
		\left[
			\begin{array}{ccccc}
				0.6444 & 0.0000 & -0.1683 & 0.1184 & 0.1973\\
				-0.0395 & 0.4208 & 0.0000 & -0.0802 & 0.0263\\
				0.0132  & -0.1184 & 0.7627 & 0.0145 & 0.0460\\
				0.0395 & 0.0000 & -0.0960 & 0.7627 & 0.0000\\
				0.0263 & -0.0395 & 0.1907 & -0.0158 & 0.5523
			\end{array}
		\right]
	\]
	Для того чтобы все собственные значения были действительными числами, домножим слева исходную матрицу на ей транспонированную:
	\[ A=A_{\text{исх.}}A_{\text{исх.}}^T=
		\left[
			\begin{array}{ccccc}
				 0.4965221 & -0.02976049 & -0.10906373 &  0.13191428 & 0.09195098\\
 				-0.02976049 & 0.18575662 & -0.05029722 & -0.06272879 & -0.0018678\\
 				-0.10906373 & -0.05029722 & 0.59823034 & -0.06163865 &  0.17564755\\
 				 0.13191428 & -0.06272879 & -0.06163865 &  0.59248754 & -0.02931901\\
 				 0.09195098 & -0.0018678  & 0.17564755 & -0.02931901 &  0.34390336
			\end{array}
		\right]
	\]
	Задача:
	\begin{enumerate}
		\item Для данной матрицы $A$ вычислить коэфициенты $p_1,p_2,\ldots,p_n$ собственного многочлена \[P(A)=\lambda^n - p_1\lambda^{n-1} - p_2\lambda^{n-2}-\ldots-p_{n-1}\lambda - p_n\]
		\subitem (проверить совпадает ли $p_1=Sp(A)$ и $p_n = \det(A)$)
		\item По  полученному характеристическому многочлену вычислить максимальное собственное значение $\lambda_{max}$ матрицы
		\item Вычислить собственный вектор $\vec{v}$ соответствующий данному значению
		\item Найти невязку $\vec{r} = A\vec{v} - \lambda_{max}\vec{v} $
	\end{enumerate}
\section{Алгоритм}
	\begin{enumerate}
		\item Находим нормальную форму Фробениуса $\Phi$ матрицы $A$
			\begin{equation*}
				\begin{aligned}
					&A_n = A\\
					&A_1 = \Phi\\
						&A_i = M_i^{-1}A_{i+1}M_i, \: i = n-1,\ldots, 1\text{, где}\\
						&M_i = \bordermatrix{& & & & & & &\cr
						& 1 & 0 & \cdots & 0 & 0 & \cdots & 0\cr
										   & 0 & 1 & \cdots & 0 & 0 & \cdots & 0\cr
										   & & &  & \cdots& \cr
										 i & -\dfrac{a_{i+1,1}^{i-1}}{a_{i+1,i}^{i-1}} & \cdots & -\dfrac{a_{i+1,i - 1}^{i-1}}{a_{i+1,i}^{i-1}} & \dfrac{1}{a_{i+1,i}^{i-1}} & -\dfrac{a_{i+1,i + 1}^{i-1}}{a_{i+1,i}^{i-1}} &\cdots &-\dfrac{a_{i+1,n}^{i-1}}{a_{i+1,i}^{i-1}} \cr
										 & & &  & \cdots& \cr
										 & 0 & 0 & \cdots & 0 & 0 & \cdots & 0\cr
										 & 0 & 0 & \cdots & 0 & 0 & \cdots & 1},\\							
						&M_i^{-1} = \bordermatrix{& & & & & & &\cr
						& 1 & 0 & \cdots & 0 & 0 & \cdots & 0\cr
										   & 0 & 1 & \cdots & 0 & 0 & \cdots & 0\cr
										   & & &  & \cdots& \cr
										 i & a_{i+1,1} & \cdots & a_{i+1,i - 1}^{i-1} & a_{i+1,i}^{i-1} & a_{i+1,i + 1}^{i-1}&\cdots & a_{i+1,n}^{i-1} \cr
										 & & &  & \cdots & \cr
										 & 0 & 0 & \cdots & 0 & 0 & \cdots & 0 \cr
										 & 0 & 0 & \cdots & 0 & 0 & \cdots & 1}.							 
				\end{aligned}
			\end{equation*}
		\item Первая строка матрицы $\Phi$ представляет собой коэфициенты $(p_1, p_2,\ldots, p_n)$ характеристического многочлена исходной матрицы
			\item Находим $\lambda_{max}$ - макисмальный корень характеристического уравнения \[\lambda^n - p_1\lambda^{n-1} - p_2\lambda^{n-2}-\ldots-p_{n-1}\lambda - p_n = 0\]
			\item По полученному $\lambda_{max}$ вычисляем собственный вектор, соотвествующий данному значению \[\]
			\begin{equation*}
					\begin{aligned}
					&\vec{v} = Sy, \: \text{где}\\
					&S = M_{n-1}M_{n-2}\ldots M_1,\\
					&y=(\lambda_{max}^{n-1}, \ldots, \lambda_{max}, 1)^T.
					\end{aligned}
			\end{equation*}
	\end{enumerate}
\section{Результаты и вывод}
	\subsection{Входные данные}
		0.6444 0.0000 -0.1683 0.1184 0.1973\\
		-0.0395 0.4208 0.0000 -0.0802 0.0263\\
		0.0132 -0.1184 0.7627 0.0145 0.0460\\
		0.0395 0.0000 -0.0960 0.7627 0.0000\\
		0.0263 -0.0395 0.1907 -0.0158 0.5523\\
	\subsection{Выходные данные}
\begin{verbatim}
Ищем собственные вектор матрицы
Исходная матрица:
[[ 0.4965221  -0.02976049 -0.10906373  0.13191428  0.09195098]
 [-0.02976049  0.18575662 -0.05029722 -0.06272879 -0.0018678 ]
 [-0.10906373 -0.05029722  0.59823034 -0.06163865  0.17564755]
 [ 0.13191428 -0.06272879 -0.06163865  0.59248754 -0.02931901]
 [ 0.09195098 -0.0018678   0.17564755 -0.02931901  0.34390336]]
Коэфициенты характеристического многочлена
 [ 2.21689996 -1.82259145  0.68304846 -0.11469321  0.0069546 ]
q_1-Sp(A) =  3.10862446895e-15 q_n-det(A) =  7.12103986888e-16
Собственное значение:  0.78083494486
Собственный вектор:  [-2.19705047  0.13110161  3.17550372 -2.77730903  1.        ]
Невязка:  [ -7.79376563e-14   2.07611706e-14  -3.13082893e-13  -2.10320650e-12
  -6.66133815e-16]
Норма невязки:  2.12791076379e-12
 \end{verbatim}
	\subsection{Вывод}
Данный метод относится к точным методам и позволяет решать проблему собственных значений. С его помощью можно находить точное решение данной проблемы, единственные погрешности которые возникают, возникают за счёт неточности машинных вычислений.\par
Сравним данный метод вычисления собственных векторов с методом Крылова, рассмотренном в предыдущей работе. Рассмотрим коэфициенты характерестического многочлена, полученные в обоих методах: 
\begin{verbatim}
[ 2.21689996 -1.82259145  0.68304846 -0.11469321  0.0069546 ] - метод Крылова
[ 2.21689996 -1.82259145  0.68304846 -0.11469321  0.0069546 ] - метод Данилевского
\end{verbatim} 
Как видим, коэфициенты совпадают, значит будут совпадать и собственные значения.\par 
Сравним собственные вектора из обоих методов(предварительно их пронормировав)
\begin{verbatim}
[-2.19705047  0.13110161  3.17550372 -2.77730903  1.        ] - метод Крылова
[-2.19705047  0.13110161  3.17550372 -2.77730903  1.        ] - метод Данилевского
\end{verbatim} 
Собственные вектора также, совпали однако можно заметить что нормы невязок этих векторов отличаються на несколько порядков, это объясняется тем, что норма собственного вектора полученного в методе Крылова \begin{verbatim}
 [ 0.00382651 -0.00022833 -0.00553064  0.00483712 -0.00174166]
 \end{verbatim}
мала сама по себе, несмотря на это количество верных цифр в обоих методах одинаково.
\section{Листинг кода}
\begin{verbatim}
import numpy as np
import numpy.linalg as linalg


# Поиск собственных векторов методом Данилевского


def eigen(matr_A):
    A = matr_A.copy()
    size = len(A)
    S = np.eye(size)
    for i in reversed(range(0, size-1)):
        M = np.eye(size)
        invM = np.eye(size)
        M[i] = [- A[i+1, j] / A[i+1, i] for j in range(size)]
        M[i, i] = 1 / A[i+1, i]
        invM[i] = [A[i+1, j] for j in range(size)]
        A = np.dot(invM, A)
        A = np.dot(A, M)
        S = np.dot(S, M)

    print("Коэфициенты характеристического многочлена\n", A[i])
    print("q_1-Sp(A) = ", abs(matr_A.trace() - A[0, 0]), "q_n-det(A) = " ,abs(linalg.det(matr_A) - A[0, size - 1]))
    p = [1] + list(A[i] * -1)  # Получили коэфициенты собственного многочлена
    eigvals = np.roots(p)
    y = [eigvals[0] ** (size - i - 1) for i in range(size)]
    return np.dot(S, y), eigvals[0]

file = open("matrix", "r")  # Чтение файла
A, b = [], []
for line in file:
    A.append([float(el) for el in line.split()[:-1]])
    b.append(float(line.split().pop()))
A = np.array(A)
A = np.dot(A, A.transpose())
b = np.array(b)
print("Ищем собственные вектор матрицы")
print("Исходная матрица:")
print(A)
ans = eigen(A)
print("Собственное значение: ", ans[1])
print("Собственный вектор: ", ans[0])
print("Невязка: ", np.dot(A, ans[0]) - ans[0] * ans[1])
print("Норма невязки: ", linalg.norm(np.dot(A, ans[0]) - ans[0] * ans[1]))
\end{verbatim}
\end{document}